#!/bin/sh
#
# Hybris adaptation bootstrapping initramfs init script.
#
# Copyright (c) 2013 Tom Swindell <t.swindell@rubyx.co.uk>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License version 2 as published by the
# Free Software Foundation.
#
# Authors:
#   - Tom Swindell <t.swindell@rubyx.co.uk>
#   - David Greaves <david@dgreaves.com>
#

# This init script runs in early boot in initrd and does a switch_root
# to the real rootfs. It can also be copied into rootfs and provide
# monitoring of the boot process there too.

CUSTOMPRODUCT="Boat Loader"
BOOTLOGO=%BOOTLOGO%
NEVERBOOT=%NEVERBOOT%
ALWAYSDEBUG=%ALWAYSDEBUG%
DATA_PARTITION=%DATA_PART%

set_welcome_msg(){
cat <<EOF >> /etc/issue.net
Welcome to the Mer/SailfishOS Boat loader debug init system.

You may inject commands into init shell process (PID 1):

To see output of commands:
  tail -f /init-ctl/stdout &
To run a command:
  echo "ls -l /" >/init-ctl/stdin
To specify an exec to boot into the system:
  echo "exec switch_root /target /init-debug" >/init-ctl/stdin
To allow init to continue:
  echo "continue" >/init-ctl/stdin

The init script also functions as a post-switch_root debug too:
  cp /init /target/init-debug

EOF
}

export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# Default setting is rndis - add mass_storage for a debug boot
# enable using usb_setup
USB_FUNCTIONS=rndis

ANDROID_USB=/sys/class/android_usb/android0
LOCAL_IP=192.168.2.1

DONE_SWITCH=no
# Are we running in real rootfs
if [ "$0" = "/init-debug" ]; then
    DONE_SWITCH=yes
fi

# Get options from kernel command line
get_opt() {
  for param in $(cat /proc/cmdline); do
    echo "$param" | grep "^$1=*" | cut -d'=' -f2
  done
}

# Minimal mounts for initrd or pre-init debug session
do_mount_devprocsys()
{
    mkdir /dev
    mount -t tmpfs tmpfs /dev

    mkdir /dev/pts
    mkdir /proc
    mkdir /sys
}

# Sugar for accessing usb config
write() {
  /bin/echo -n "$2" > "$1"
}

inject_loop() {
    INJ_DIR=/init-ctl
    INJ_STDIN=$INJ_DIR/stdin
    INJ_STDOUT=$INJ_DIR/stdout

    mkdir $INJ_DIR
    mkfifo $INJ_STDIN
    mkfifo $INJ_STDOUT

    while : ; do
        while read IN; do
            $IN >$INJ_STDOUT 2>&1
        done <$INJ_STDIN
    done
}

# This sets up the USB with whatever USB_FUNCTIONS are set to
usb_setup() {
      write $ANDROID_USB/enable        0
      write $ANDROID_USB/idVendor      18D1
      write $ANDROID_USB/idProduct     D001
      write $ANDROID_USB/iManufacturer "Mer"
      write $ANDROID_USB/iProduct      "$CUSTOMPRODUCT"
      write $ANDROID_USB/iSerial       "$1"
      write $ANDROID_USB/functions     $USB_FUNCTIONS
      write $ANDROID_USB/enable        1
}
# This lets us communicate errors to host (if it needs disable/enable then that's a problem)
usb_info() {
      write $ANDROID_USB/iSerial       $@
}


run_debug_session() {
    # During debug we export mmc too
    echo /dev/mmcblk0 > /sys/class/android_usb/f_mass_storage/lun0/file

    USB_FUNCTIONS=rndis,mass_storage
    usb_setup "Mer Debug setting up"
    sleep 1

    USB_IFACE=notfound
    /bin/ifconfig usb0   $LOCAL_IP && USB_IFACE=usb0
    /bin/ifconfig rndis0 $LOCAL_IP && USB_IFACE=rndis0

    # Unable to set up USB interface? Reboot. 
    if [ x$USB_IFACE = xnotfound ]; then
	usb_info "Mer Debug: ERROR: could not setup USB as usb0 or rndis0"
	sleep 900
	reboot -f
    fi 

    /bin/echo "interface $USB_IFACE" >> /etc/udhcpd.conf
    # Be explicit about busybox so this works in a rootfs too
    $EXPLICIT_BUSYBOX udhcpd

    set_welcome_msg
    # Non-blocking telnetd
    $EXPLICIT_BUSYBOX telnetd -p 23 -l /bin/sh

    usb_info "Mer Debug telnet on port 23 on $USB_IFACE $LOCAL_IP - also running udhcpd"

    # Run command injection loop
    inject_loop

    # User has been into debug and killed telnet, hoping for boot to continue
    USB_FUNCTIONS=rndis
    echo "" > /sys/class/android_usb/f_mass_storage/lun0/file
    usb_setup "Post-debug boot"
}

# writes to /diagnosis.log if there's a problem
check_kernel_config() {
    if [ ! -e /proc/config.gz ]; then
	echo "No /proc/config.gz. Enable CONFIG_IKCONFIG and CONFIG_IKCONFIG_PROC" >> /diagnosis.log
    else
	# Must be =y
	for x in CONFIG_CGROUPS CONFIG_AUTOFS4_FS CONFIG_DEVTMPFS_MOUNT CONFIG_DEVTMPFS CONFIG_UNIX CONFIG_HOTPLUG CONFIG_INOTIFY_USER CONFIG_SYSVIPC CONFIG_NET CONFIG_PROC_FS CONFIG_SIGNALFD CONFIG_SYSFS CONFIG_TMPFS_POSIX_ACL CONFIG_VT; do
		zcat /proc/config.gz | grep -E "^$x=y\$" || echo "$x=y not found in /proc/config.gz" >> /diagnosis.log
 	done
	# Must not be =y
	for x in CONFIG_ANDROID_LOW_MEMORY_KILLER CONFIG_ANDROID_PARANOID_NETWORK CONFIG_DUMMY CONFIG_SYSFS_DEPRECATED; do
		zcat /proc/config.gz | grep -E "^$x=y\$" && echo "$x=y found in /proc/config.gz, must be disabled" >> /diagnosis.log
	done
    fi
}

# Now either initrd or rootfs sequence

if [ "$DONE_SWITCH" = "no" ]; then
    EXPLICIT_BUSYBOX=""
    /bin/busybox --install -s

    do_mount_devprocsys

    mount -a
    ln -s /proc/mounts /etc/mtab

    echo /sbin/mdev > /proc/sys/kernel/hotplug
    mdev -s

    # Support /dev/block/mmcXXX
    ln -s . /dev/block

    # There is no way to know when all hotplug events have been processed :(
    sleep 2

    if [ x$BOOTLOGO = x1 ]; then
	zcat /bootsplash.gz > /dev/fb0
    fi

    check_kernel_config

    if [ -e /diagnosis.log ]; then
	CUSTOMPRODUCT="Refusing to boot. See /diagnosis.log (in initrd only)"
	run_debug_session
	sleep 900
	reboot -f
    fi

    if [ x$NEVERBOOT = x1 ]; then
	CUSTOMPRODUCT="Set to never boot"
	run_debug_session
	sleep 3600
	reboot -f
    fi

    if [ x$ALWAYSDEBUG = x1 ]; then
	CUSTOMPRODUCT="Always debug"
	run_debug_session
    fi

    if [ ! -z $DATA_PARTITION ]; then
	mkdir /data
	mkdir /target

	mount $DATA_PARTITION /data
	mount --bind /data/.stowaways/sffe /target
	mkdir /target/data # in new fs
	mount --bind /data /target/data
    fi

    # Check for special bootmode flags and process accordingly.
    case "$(get_opt bootmode)" in
	debug)
	    CUSTOMPRODUCT="bootmode=debug on kernel command line"
	    run_debug_session
	    ;;

	*)
	    if [ -f "/target/init-debug" ]; then
		exec switch_root /target /init-debug &> /target/init-debug-stderrout
	    else
		if [ -e "/target/sbin/init" ]; then
		    exec switch_root /target /sbin/init --log-level=debug --log-target=kmsg &> /target/init-stderrout
		fi
	    fi
	    CUSTOMPRODUCT="Failed to boot init in real rootfs"
	    run_debug_session
	    ;;
    esac
    sleep 3600
else
    # We're in the real rootfs running as init-debug
    EXPLICIT_BUSYBOX="/bin/busybox"
    do_mount_devprocsys
    CUSTOMPRODUCT="init-debug in real rootfs"
    run_debug_session

    # Now try to boot
    exec /sbin/init --log-level=debug --log-target=kmsg &> /boot/systemd_stdouterr
    CUSTOMPRODUCT="init in real rootfs failed"
    run_debug_session
fi
